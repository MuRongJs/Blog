{"data":{"content":{"edges":[{"node":{"id":"2ed1d92c-7abd-5798-9eb4-0208234dcfab","html":"<h1 id=\"1iterator遍历器的概念\"><a href=\"#1iterator%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5\" aria-label=\"1iterator遍历器的概念 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.iterator(遍历器)的概念</h1>\n<p>1、为不同的数据结构，提供统一的访问接口；</p>\n<p>2、使得数据结构的成员能够按某种次序排序；</p>\n<p>3、for...of语句来遍历含有iterator接口的数据；</p>\n<p>4、遍历过程：（1）创建一个指针对象。（2）指针指向数据成员的位置。（3）使用next方法让指针指向下一个数据成员</p>\n<p>5、next方法：每次调用next方法时返回都会包含value和done两个属性的对象，其中value是当前成员的值，done是一个表示遍历是否结束的布尔值。</p>\n<p>iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。</p>\n<hr>\n<h1 id=\"2、-默认iterator\"><a href=\"#2%E3%80%81-%E9%BB%98%E8%AE%A4iterator\" aria-label=\"2、 默认iterator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2、 默认iterator</h1>\n<p>原生具有iterator接口的数据结构如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">1.array\n2.map\n3.set\n4.string\n5.typedarray\n6.函数的arguments对象\n7.nodelist对象</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>不具备iterator接口的只要在symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>\n<p>for...of遍历有iterator接口对象时，首先\t会先返回一个遍历对象，对象有next方法。</p>\n<pre>\n例一：\n\tconst obj = {\n\t  [symbol.iterator] : function () {\n\t    return {\n\t      next: function () {\n\t        return {\n\t          value: 1,\n\t          done: true\n\t        };\n\t      }\n\t    };\n\t  }\n\t};\n例二：\n\tclass rangeiterator {\n\t  constructor(start, stop) {\n\t    this.value = start;\n\t    this.stop = stop;\n\t  }\n\t\n\t  [symbol.iterator]() { return this; }\n\t\n\t  next() {\n\t    var value = this.value;\n\t    if (value < this.stop) {\n\t      this.value++;\n\t      return {done: false, value: value};\n\t    }\n\t    return {done: true, value: undefined};\n\t  }\n\t}\n\t\n\tfunction range(start, stop) {\n\t  return new rangeiterator(start, stop);\n\t}\n\t\n\tfor (var value of range(0, 3)) {\n\t  console.log(value); // 0, 1, 2\n\t}\n</pre>\n<h1 id=\"3、调用iterator接口的场合\"><a href=\"#3%E3%80%81%E8%B0%83%E7%94%A8iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88\" aria-label=\"3、调用iterator接口的场合 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3、调用iterator接口的场合</h1>\n<p>(1. 解构赋值</p>\n<p>(2. 扩展运算符（...)可以将任何具有iterator接口的数据结构转为数组 ： var str=\"asdfgh\"; [...str];\t//[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]</p>\n<p>(3. yield*</p>\n<pre>\nvar iterator = function*(){\n\tyield 1;\n\tyield* [2,3,4];\n}\n</pre>\n<p>(4. 其他场合：任何接受数组的参数的场合，都调用了遍历接口。\n\nfor...of\narray.from()\nmap()、set()、weakmap()、weakset()\npromise.all()\npromise.race()</p>\n<h1 id=\"4、字符串的iterator接口\"><a href=\"#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84iterator%E6%8E%A5%E5%8F%A3\" aria-label=\"4、字符串的iterator接口 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/iterator#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84-iterator-%e6%8e%a5%e5%8f%a3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">4、字符串的iterator接口</a></h1>\n<h1 id=\"5、iterator接口与generator函数\"><a href=\"#5%E3%80%81iterator%E6%8E%A5%E5%8F%A3%E4%B8%8Egenerator%E5%87%BD%E6%95%B0\" aria-label=\"5、iterator接口与generator函数 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5、iterator接口与generator函数</h1>\n<p>用generator函数实现一个有iterator接口的对象。</p>\n<pre>\nvar myiterator = {\n\t[symbol.iterator]:function* (){\n\t\tyield:1;\n\t\tyield:2;\n\t\tyield:3;\n\t\tyield:4;\n\t}\n}\n//等同于\nvar myiterator = {\n\t* [symbol.iterator](){\n\t\tyield 'hello';\n    \tyield 'world';\n\t}\n}\n</pre>\n<p>generator函数执行，产生一个有iterator接口的对象。</p>\n<h1 id=\"6、遍历器对象的-returnthrow\"><a href=\"#6%E3%80%81%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-returnthrow\" aria-label=\"6、遍历器对象的 returnthrow permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/iterator#%e9%81%8d%e5%8e%86%e5%99%a8%e5%af%b9%e8%b1%a1%e7%9a%84-return%ef%bc%8cthrow\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6、遍历器对象的 return(),throw()</a></h1>\n<p>return方法主要在for...of循环中提前退出（出错，break语句）的时候调用。如果在对象完成遍历前，需要清理或释放资源，就可以部署return方法。</p>\n<p><strong>return方法必须返回一个对象</strong></p>\n<h1 id=\"7、forof循环\"><a href=\"#7%E3%80%81forof%E5%BE%AA%E7%8E%AF\" aria-label=\"7、forof循环 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7、for...of循环</h1>\n<p>用来遍历所有数据结构的统一方法。数据结构只要部署了[symbol.iterator]属性，就视为有iterator接口，就可以用for...of来遍历。for...of遍历的数据结构就是遍历[symbol.iterator]返回的对象。</p>\n<p>for...of循环可以使用的范围包括数组、set 和 map 结构、某些类似数组的对象（比如arguments对象、dom nodelist 对象）、后文的 generator 对象，以及字符串。</p>\n<h3 id=\"数组\"><a href=\"#%E6%95%B0%E7%BB%84\" aria-label=\"数组 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>数组</h3>\n<p>数组情况下：</p>\n<p>for...in循环，只能获取键名，不能获取到键值。for...of循环直接遍历可得到键值（如果要得到键名借助数组实例的entries方法和keys方法）</p>\n<p>for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。例如：</p>\n<pre>\nlet arr = [3, 5, 7];\narr.foo = 'hello';\n\nfor (let i in arr) {\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\n}\n\nfor (let i of arr) {\n  console.log(i); //  \"3\", \"5\", \"7\"\n}\n</pre>\n<h3 id=\"set-和-map结构\"><a href=\"#set-%E5%92%8C-map%E7%BB%93%E6%9E%84\" aria-label=\"set 和 map结构 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>set 和 map结构</h3>\n<p>set数据结构，使用for...of循环遍历的时候，每次遍历返回的是一个值。</p>\n<p>map数据结构，使用for...of循环遍历的时候，每次遍历返回的是一个数组（当前map成员的键名和键值）。</p>\n<h3 id=\"计算生成的数据结构\"><a href=\"#%E8%AE%A1%E7%AE%97%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" aria-label=\"计算生成的数据结构 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>计算生成的数据结构</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">1.entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。\n2.keys() 返回一个遍历器对象，用来遍历所有的键名。\n3.values() 返回一个遍历器对象，用来遍历所有的键值。</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"类似数据的对象\"><a href=\"#%E7%B1%BB%E4%BC%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1\" aria-label=\"类似数据的对象 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>类似数据的对象</h3>\n<p>类似数据的对象（字符串、DOM NodeList 对象、arguments对象）。</p>\n<p>for...of可以识别32位utf-16的字符。</p>\n<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</p>\n<h3 id=\"对象\"><a href=\"#%E5%AF%B9%E8%B1%A1\" aria-label=\"对象 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对象</h3>\n<p>普通对象，可以使用for...in循环遍历对象的键名，但是不能直接使用for...of循环遍历（因为普通对象没有[Symbol.iterator]接口个）</p>\n<p>普通对象可以使用Generator生成器生成一个可以遍历的对象，然后就可以使用for...of循环遍历了。</p>\n<h3 id=\"与其他遍历语法的比较\"><a href=\"#%E4%B8%8E%E5%85%B6%E4%BB%96%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83\" aria-label=\"与其他遍历语法的比较 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/iterator#%E4%B8%8E%E5%85%B6%E4%BB%96%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">与其他遍历语法的比较</a>)</h3>","excerpt":"1.iterator(遍历器)的概念1、为不同的数据结构，提供统一的访问接口；2、使得数据结构的成员能够按某种次序排序；3、for...of语句来遍历含有iterator接口的数据；4、遍历过程：（1）创建一个指针对象。（2）指针指向数据成员的位置。（3）使用next…","fields":{"slug":"/blog/es6/Iterator和for...of循环"},"frontmatter":{"id":"https://MuRongJs.github.io/blog/es6/Iterator和for...of循环","title":"es6-Iterator和for...of循环","slug":"/blog/es6/Iterator和for...of循环","date":"2018/11/14 22:34:48","headerImage":""}},"previous":null,"next":null}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"2ed1d92c-7abd-5798-9eb4-0208234dcfab","index":13}}