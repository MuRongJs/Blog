{"data":{"content":{"edges":[{"node":{"id":"3cfa0c4f-3b54-56b4-a4ee-af75dc0f0270","html":"<h1 id=\"1、简介\"><a href=\"#1%E3%80%81%E7%AE%80%E4%BB%8B\" aria-label=\"1、简介 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1、简介</h1>\n<h3 id=\"基本概念\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\" aria-label=\"基本概念 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>基本概念</h3>\n<p>Generator是异步编程的一种解决方案。</p>\n<p>(1)从语法方面理解Generator，它是一个状态机，封装了多个内部状态。执行Generator函数返回一个可以遍历的对象，内部有Generator函数封装的全部状态。</p>\n<p>(2)从形式上看，它是一个声明时需要在function和函数名中间加一个\" * \"，内部可以使用yield关键字的函数。在执行Genertator函数时返回一个指向内部状态的指针对象。</p>\n<p>总结：调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>\n<h3 id=\"yield-表达式\"><a href=\"#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F\" aria-label=\"yield 表达式 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>yield 表达式</h3>\n<p>概念：Generator函数返回的可遍历对象，只有调用next方法才会遍历下一个内部状态，所以Generator函数提供了一种可以暂停执行的函数，yield表达式就是暂停标志。</p>\n<p>Generator中的next方法运行步骤：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">1.遇到yield表达式，暂停执行后面的操作，并将yield表达式后面的值，以返回对象的value属性的属性值形式返回。\n2.调用next方法时接续执行，直到遇到下一个yield表达式。\n3.如果没有遇到yield表达式，就已知运行函数到结束，直到遇到return 。\n4.如果没有return，则返回对象的value属性值为undefined。</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p> Generator函数执行只会返回一个可以遍历的对象，但是不会不会执行内部的代码。</p>\n<p> <strong>注意：1、yield表达式只能在Generator函数内部使用。2、如果需要在另一个表达式用到yield表达式，必须带圆括号</strong></p>\n<h3 id=\"与iterator接口的关系\"><a href=\"#%E4%B8%8Eiterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB\" aria-label=\"与iterator接口的关系 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>与Iterator接口的关系</h3>\n<p> 有[Symbol.iterator]方法的对象，该方法是对象的遍历器生成函数，该方法会返回该对象的遍历对象。</p>\n<p> Generator函数也是遍历器生成函数，因此将Generator函数赋值给对象的[Symbol.iterator]属性，对象就会具有iterator接口。</p>\n<p> <strong>Generatro函数执行会返回一个可遍历的对象，该对象有[Symbol.iterator]接口，执行[Symbol.iterator]方法的时候会返回自己本身</strong></p>\n<h1 id=\"2、next方法的参数\"><a href=\"#2%E3%80%81next%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0\" aria-label=\"2、next方法的参数 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2、next方法的参数</h1>\n<p> yield表达式本身没有返回值（返回undefined），如果在next中传入参数，这个参数可以当成上个yield表达式的返回值（第一个next参数被忽略）。</p>\n<p> <strong>Generator函数从暂停状态到恢复运行，它的上下文（context）不变，通过next方法参数，可以在Generator函数不同阶段注入不同的值，进而调整函数行为</strong></p>\n <pre>\n function* foo(){\n    console.log('start');\n    console.log(`'first' + ${yield}`);\n    console.log(`'second' + ${yield}`);\n    console.log('end');\n }\n var g = foo();\n g.next();//start\n g.next('1');//first1\n g.next('2');//second2\n g.next();//end\n </pre>\n<h1 id=\"3、forof循环\"><a href=\"#3%E3%80%81forof%E5%BE%AA%E7%8E%AF\" aria-label=\"3、forof循环 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3、for...of循环</h1>\n<p> 自动遍历Generator函数生成的遍历对象，不需要调用next方法。</p>\n<p> 遍历一个没有iterator接口的普通对象：</p>\n <pre>\n function* entireObj(obj){\n    var objKey = Reflect.ownKeys(obj);\n    for(var key of objKey){\n        yield [key, obj[key]];\n    }\n }\n var obj = {\n    name: \"crl\",\n    age:\"24\",\n    addr:\"beijing\"\n }\n for(var [key, val] of entireObj(obj)){\n    console.log(\"键名:\" + key);\n    console.log(\"键值:\" + val);\n }\n //等同于\n function* objectEntries() {\n   let propKeys = Object.keys(this);\n \n   for (let propKey of propKeys) {\n     yield [propKey, this[propKey]];\n   }\n }\n \n let jane = { first: 'Jane', last: 'Doe' };\n \n jane[Symbol.iterator] = objectEntries;\n </pre>\n<h1 id=\"4、generatorprototypethrow\"><a href=\"#4%E3%80%81generatorprototypethrow\" aria-label=\"4、generatorprototypethrow permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-prototype-throw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">4、Generator.prototype.throw()</a></h1>\n<p> Generator函数返回的遍历器对象，有一个throw方法，可以在函数体外抛出错，在Generator函数体内捕获。</p>\n<p> 如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。</p>\n<p> throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。</p>\n<p> throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。</p>\n<p> 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p>\n<h1 id=\"5、generatorprototypereturn\"><a href=\"#5%E3%80%81generatorprototypereturn\" aria-label=\"5、generatorprototypereturn permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5、Generator.prototype.return()</h1>\n<p> Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>\n<p> 如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>\n<pre>\nfunction* g(){\n    yield 1;\n    try{\n        yield 2;\n        yield 3;\n    }finally{\n        yield 4;\n        yield 5;\n    }\n}\nvar i = g();\ni.next();\ni.next();\ni.return('7');\ni.next();\ni.next();\n</pre>\n<h1 id=\"6、next、throw、return-的共同点\"><a href=\"#6%E3%80%81next%E3%80%81throw%E3%80%81return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9\" aria-label=\"6、next、throw、return 的共同点 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#next%E3%80%81throw%E3%80%81return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6、next()、throw()、return() 的共同点</a></h1>\n<p>next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。</p>\n<p>next()是将yield表达式替换成一个值。</p>\n<p>throw()是将yield表达式替换成一个throw语句。</p>\n<p>return()是将yield表达式替换成一个return语句。</p>\n<h1 id=\"7、yield-表达式\"><a href=\"#7%E3%80%81yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F\" aria-label=\"7、yield 表达式 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7、yield* 表达式</h1>\n<p>yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>\n<p>如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。</p>\n<pre>\nfunction* concat(iter1, iter2) {\n  yield* iter1;\n  yield* iter2;\n}\n\n// 等同于\n\nfunction* concat(iter1, iter2) {\n  for (var value of iter1) {\n    yield value;\n  }\n  for (var value of iter2) {\n    yield value;\n  }\n}\n</pre>\n<p>如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。</p>\n<h1 id=\"8、作为对象属性的generator函数\"><a href=\"#8%E3%80%81%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84generator%E5%87%BD%E6%95%B0\" aria-label=\"8、作为对象属性的generator函数 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8、作为对象属性的Generator函数</h1>\n<p>如果对象的属性是Generator函数，可以写成如下形式：</p>\n<pre>\nobj = {\n    myG:funciton*(){\n        ..//\n    }\n}\n//等同于\nobj = {\n    * myG(){\n        ..//\n    }\n}\n</pre>\n<h1 id=\"9、generator函数的this\"><a href=\"#9%E3%80%81generator%E5%87%BD%E6%95%B0%E7%9A%84this\" aria-label=\"9、generator函数的this permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-%E5%87%BD%E6%95%B0%E7%9A%84this\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">9、Generator函数的this</a></h1>\n<p>Generator函数运行返回一个可遍历的对象，这个对象是Generator函数的实例，继承了Generator函数的prototype对象上的属性和方法。</p>\n<p>但是由于Generatot函数不能使用new命令，所以在Generator函数内部的this上定义的属性并不能继承。于是就可以写成如下例子：</p>\n<pre>\n//Generator函数运行产生的可遍历的对象，执行[Symbol.iterator]方法时返回的是本身。\nfunction* g(){\n    yield 1;\n}\nvar gObj = g();\ngObj[Symbol.iterator]() === gObj;\n\n//怎样产生既是Generaotr函数的实例又继承了Generator函数内部this 的对象。\nfunction* myGen(){\n    this.a = \"aaa\";\n    this.b = \"bbb\";\n    yield \"adf\";\n}\nvar f = myGen.call(myGen.prototype);\n//等同于\nfunction* myGen(){\n    this.a = \"aaa\";\n    this.b = \"bbb\";\n    yield \"adf\";\n}\nfunction getMyGen(){\n    return myGen.call(myGen.prototype);\n}\nvar f = new getMyGen();\n//也可以传参\n</pre>\n<p><strong>Generator函数执行返回一个实例，但是Generator函数内部并没有执行，只有使用next方法时会执行内部代码，并且只执行到当前下个yield关键字之间的代码</strong></p>\n<h1 id=\"10、含义\"><a href=\"#10%E3%80%81%E5%90%AB%E4%B9%89\" aria-label=\"10、含义 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>10、含义</h1>\n<h3 id=\"generator与状态机\"><a href=\"#generator%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA\" aria-label=\"generator与状态机 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Generator与状态机</a></h3>\n<p>Generator拥有状态信息（是否处于暂停状态）</p>\n<h3 id=\"generator与协程\"><a href=\"#generator%E4%B8%8E%E5%8D%8F%E7%A8%8B\" aria-label=\"generator与协程 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-%E4%B8%8E%E5%8D%8F%E7%A8%8B\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Generator与协程</a></h3>\n<p>协程是一种程序执行的方式，可以理解为\"协作的线程\"或\"协作的函数\"。</p>\n<p>协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>\n<h4 id=\"（1）协程和子例程的差异\"><a href=\"#%EF%BC%881%EF%BC%89%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%AD%90%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82\" aria-label=\"（1）协程和子例程的差异 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>（1）协程和子例程的差异</h4>\n<p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。</p>\n<p>协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>\n<h4 id=\"2-协程与普通线程的差异\"><a href=\"#2-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82\" aria-label=\"2 协程与普通线程的差异 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(2) 协程与普通线程的差异</h4>\n<p>协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>\n<p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>\n<p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>\n<p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权。</p>\n<h3 id=\"generator与上下文\"><a href=\"#generator%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87\" aria-label=\"generator与上下文 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Generator与上下文</a></h3>\n<p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p>\n<p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p>\n<p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p>\n<h1 id=\"11、应用\"><a href=\"#11%E3%80%81%E5%BA%94%E7%94%A8\" aria-label=\"11、应用 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>11、应用</h1>\n<h3 id=\"1异步操作的同步化表示\"><a href=\"#1%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8C%96%E8%A1%A8%E7%A4%BA\" aria-label=\"1异步操作的同步化表示 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#%EF%BC%881%EF%BC%89%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8C%96%E8%A1%A8%E8%BE%BE\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(1)异步操作的同步化表示</a></h3>\n<pre>\nfunction* main() {\n  var result = yield request(\"http://some.url\");\n  var resp = JSON.parse(result);\n    console.log(resp.value);\n}\n\nfunction request(url) {\n  makeAjaxCall(url, function(response){\n    it.next(response);\n  });\n}\n\nvar it = main();\nit.next();\n</pre>\n<h3 id=\"2控制流管理\"><a href=\"#2%E6%8E%A7%E5%88%B6%E6%B5%81%E7%AE%A1%E7%90%86\" aria-label=\"2控制流管理 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/generator#%EF%BC%882%EF%BC%89%E6%8E%A7%E5%88%B6%E6%B5%81%E7%AE%A1%E7%90%86\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(2)控制流管理</a></h3>\n<p><strong>同步执行下的控制流管理，例如：</strong></p>\n<pre>\nfunction step1(){\n    return \"第一步：返回值可以传递给下一步\";\n}\nfunction step2(){\n    return \"第二步：返回值可以传递给下一步\";\n}\nfunction step3(){\n    return \"第三步：返回值可以传递给下一步\";\n}\nfunction step4(){\n    return \"第四步：返回值可以传递给下一步\";\n}\n//例一\nfunction* gen(){\n    var res1 = yield step1();\n    console.log(res1);\n    var res2 = yield step2();\n    console.log(res2);\n    var res3 = yield step3();\n    console.log(res3);\n    var res4 = yield step4();\n    console.log(res4);\n}\nfunction runGen(genFunRes){\n    var iterRes = genFunRes.next(genFunRes.value);//genFunRes.value 是Generator函数产生的迭代器对象，用户自定义的value值。\n    if(!iterRes.done){\n        genFunRes.value = iterRes.value;//iterRes.value 是迭代器对象next方法产生的对象。\n        return runGen(genFunRes);\n    }else{\n        return;\n    }\n}\n</pre>\n<h3 id=\"3部署iterator接口\"><a href=\"#3%E9%83%A8%E7%BD%B2iterator%E6%8E%A5%E5%8F%A3\" aria-label=\"3部署iterator接口 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(3)部署Iterator接口</h3>\n<h3 id=\"4作为数据结构\"><a href=\"#4%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" aria-label=\"4作为数据结构 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(4)作为数据结构</h3>\n<p>Generator可以看作是数据结构，准确的说是数组结构，它返回的值可以提供类似数据的接口。</p>\n<pre>\nfunction* doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n//上面的写法可以用数组模拟\nfunction doStuff() {\n  return [\n    fs.readFile.bind(null, 'hello.txt'),\n    fs.readFile.bind(null, 'world.txt'),\n    fs.readFile.bind(null, 'and-such.txt')\n  ];\n}\n</pre>","excerpt":"1、简介基本概念Generator是异步编程的一种解决方案。(1)从语法方面理解Generator，它是一个状态机，封装了多个内部状态。执行Generator函数返回一个可以遍历的对象，内部有Generator函数封装的全部状态。(…","fields":{"slug":"/blog/es6/Generator 函数的语法"},"frontmatter":{"id":"https://MuRongJs.github.io/blog/es6/Generator 函数的语法","title":"es6-Generator 函数的语法","slug":"/blog/es6/Generator 函数的语法","date":"2018/11/15 22:34:48","headerImage":""}},"previous":null,"next":null}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"188e8f9f-c6ad-5dae-9a8b-aa3b6a380e8e","index":14}}