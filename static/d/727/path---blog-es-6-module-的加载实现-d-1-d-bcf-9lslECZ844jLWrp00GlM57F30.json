{"data":{"content":{"edges":[{"node":{"id":"95003ed6-9713-5267-b8d7-edd7caa2596d","html":"<h1 id=\"1、类的修饰器\"><a href=\"#1%E3%80%81%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8\" aria-label=\"1、类的修饰器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1、类的修饰器</h1>\n<p>修饰器就是对类进行处理的函数（提案）。可以对类添加静态属性、实例属性、私有属性。</p>\n<p><strong>注意</strong>:修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p>\n<pre>\nfunction addAttr(attr, attrVal){\n    return function(target){\n        target.attr = attrVal;\n        target.prototype.attr = attrVal;\n    }\n}\n@addAttr(\"name\", \"murong\")\nclass person{\n    \n}\n</pre>\n<h1 id=\"2、属性的修饰\"><a href=\"#2%E3%80%81%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BF%AE%E9%A5%B0\" aria-label=\"2、属性的修饰 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/decorator#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BF%AE%E9%A5%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">2、属性的修饰</a></h1>\n<p>修饰器不仅可以修饰类，还可以修饰类的属性。</p>\n<p>修饰器函数修饰属性时，一共接受三个参数，目标对象、属性名、描述对象。</p>\n<pre>\nfunction add1(target, name, descriptor){\n    let fVal = descriptor.value;\n    descriptor.value = function () {\n        arguments[0]++;\n        return fVal.apply(this, arguments);\n    }\n    return descriptor;\n}\nfunction  log(target, name, descriptor) {\n    let fVal = descriptor.value;\n    descriptor.value = function () {\n        console.log(`${name}` , arguments);\n        return fVal.apply(this, arguments);\n    }\n    return descriptor;\n}\n@addAttr(\"name\", \"murong\")\nclass person{\n    @add1\n    @log add(a, b){\n        return a + b;\n    }\n}\nlet p = new person();\nconsole.log(p.add(1,2));//增加类add1修饰器，会在第一个参数加1；\nconsole.log(Object.getPrototypeOf(p).add.toString());\nconsole.log(Object.getOwnPropertyDescriptor(Object.getPrototypeOf(p) , \"add\").value.toString());\n//在类内部定义的属性（也可以称为在类的原型对象上定义的属性）通过修饰符函数修饰。value为修饰函数修饰后的值。\n</pre>\n<p>如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p>\n<p>它将是 JavaScript 代码静态分析的重要工具。</p>\n<h1 id=\"3、为什么修饰器不能用于函数？\"><a href=\"#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F\" aria-label=\"3、为什么修饰器不能用于函数？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/decorator#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">3、为什么修饰器不能用于函数？</a></h1>\n<p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>\n<p>如果一定要修饰函数，可以采用高阶函数的形式直接执行。</p>\n<pre>\nfunction doSomething(name) {\n  console.log('Hello, ' + name);\n}\n\nfunction loggingDecorator(wrapped) {\n  return function() {\n    console.log('Starting');\n    const result = wrapped.apply(this, arguments);\n    console.log('Finished');\n    return result;\n  }\n}\n\nconst wrapped = loggingDecorator(doSomething);\n</pre>\n<h1 id=\"4、core-decoratorjs\"><a href=\"#4%E3%80%81core-decoratorjs\" aria-label=\"4、core decoratorjs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/decorator#core-decorators-js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">4、core-decorator.js</a></h1>\n<p>core-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p>\n<h3 id=\"1autobind\"><a href=\"#1autobind\" aria-label=\"1autobind permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(1)@autobind</h3>\n<p>autobind修饰器使得方法中的this对象，绑定原始对象。</p>\n<h3 id=\"2readonly\"><a href=\"#2readonly\" aria-label=\"2readonly permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(2)@readonly</h3>\n<p>readonly修饰器使得属性或方法不可写。</p>\n<h3 id=\"3override\"><a href=\"#3override\" aria-label=\"3override permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(3)@override</h3>\n<p>override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p>\n<h3 id=\"4deprecate-别名deprecated\"><a href=\"#4deprecate-%E5%88%AB%E5%90%8Ddeprecated\" aria-label=\"4deprecate 别名deprecated permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(4)@deprecate (别名@deprecated)</h3>\n<p>deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。</p>\n<h3 id=\"5suppresswarnings\"><a href=\"#5suppresswarnings\" aria-label=\"5suppresswarnings permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(5)@suppressWarnings</h3>\n<p>suppressWarnings修饰器抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。</p>\n<h1 id=\"5、使用修饰器实现自动发布事件\"><a href=\"#5%E3%80%81%E4%BD%BF%E7%94%A8%E4%BF%AE%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6\" aria-label=\"5、使用修饰器实现自动发布事件 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5、<a href=\"http://es6.ruanyifeng.com/#docs/decorator#%E4%BD%BF%E7%94%A8%E4%BF%AE%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用修饰器实现自动发布事件</a></h1>\n<pre>\nconst postal = require(\"postal/lib/postal.lodash\");\n\nexport default function publish(topic, channel) {\n  const channelName = channel || '/';\n  const msgChannel = postal.channel(channelName);\n  msgChannel.subscribe(topic, v => {\n    console.log('频道: ', channelName);\n    console.log('事件: ', topic);\n    console.log('数据: ', v);\n  });\n\n  return function(target, name, descriptor) {\n    const fn = descriptor.value;\n\n    descriptor.value = function() {\n      let value = fn.apply(this, arguments);\n      msgChannel.publish(topic, value);\n    };\n  };\n}\n</pre>\n<p>上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是<a href=\"https://github.com/postaljs/postal.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Postal.js</a>。</p>\n<h1 id=\"6、mixin\"><a href=\"#6%E3%80%81mixin\" aria-label=\"6、mixin permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/decorator#Mixin\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6、Mixin</a></h1>\n<p>在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p>\n<p>Mixin是一种概念</p>\n<p>混入可以使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">1.Object.assign(target , source),将要混入的对象，混入到目的对象。\n2.修饰符进行混入，利用Object.assign和高级函数的形式给类的原型对象进行混入。\n3.可以用类的继承方式(继承方式是将类的原型的原型指向父类的原型上)混入,可以在混入类中调用父类。例如：</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<pre>\nclass b{\n\tb(){\n\t\tconsole.log(\"b\");\n\t}\n}\nclass c{\n\tc(){\n\t\tconsole.log(\"c\");\n\t}\n}\nclass d{\n\td(){\n\t\tconsole.log(\"d\");\n\t}\n}\nclass e{\n\te(){\n\t\tconsole.log(\"e\");\n\t}\n}\nvar mixinE = (superClass) => class extends superClass{\n \te(){\n \t\tconsole.log(\"e\");\n \t}\n };\n var mixinD = (superClass) => class extends superClass{\n \td(){\n \t\tconsole.log(\"d\");\n \t}\n };\n var mixinC = (superClass) => class extends superClass{\n \tc(){\n \t\tconsole.log(\"c\");\n \t}\n };\n var mixinB = (superClass) => class extends superClass{\n \tb(){\n \t\tconsole.log(\"b\");\n \t}\n };\n class f extends mixinB(mixinC(mixinD(e))){\n \tf(){\n \t\tconsole.log(\"f\")\n \t}\n }\n var f1 = new f();\n \n</pre>\n<h1 id=\"7、trait\"><a href=\"#7%E3%80%81trait\" aria-label=\"7、trait permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/decorator#Trait\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">7、Trait</a></h1>\n<p><strong><a href=\"https://github.com/CocktailJS/traits-decorator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">traits-decorator</a></strong></p>\n<p>Trait是一个第三方的模块，效果和Mixin类似，它能防止同名方法的通途、排除混入某些方法、为混入的方法起别名等。它能接受对象，也可以接受es6的类。</p>\n<pre>\nimport { traits, alias } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.aliasFoo() // foo\nobj.bar() // bar\n//也可以组合写    \n@traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))\nclass MyClass {}\n</pre>\n<h1 id=\"8、babel转码器支持decorator\"><a href=\"#8%E3%80%81babel%E8%BD%AC%E7%A0%81%E5%99%A8%E6%94%AF%E6%8C%81decorator\" aria-label=\"8、babel转码器支持decorator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"http://es6.ruanyifeng.com/#docs/decorator#Babel-%E8%BD%AC%E7%A0%81%E5%99%A8%E7%9A%84%E6%94%AF%E6%8C%81\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">8、Babel转码器支持Decorator</a></h1>","excerpt":"1、类的修饰器修饰器就是对类进行处理的函数（提案）。可以对类添加静态属性、实例属性、私有属性。注意:修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。…","fields":{"slug":"/blog/es6/Decorator"},"frontmatter":{"id":"https://MuRongJs.github.io/blog/es6/Decorator","title":"es6-Decorator","slug":"/blog/es6/Decorator","date":"2018/11/21 22:34:48","headerImage":""}},"previous":null,"next":null}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"0510b001-5f17-5b22-8f19-00c561015755","index":9}}