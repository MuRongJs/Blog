{"data":{"content":{"edges":[{"node":{"id":"51ce5e2b-74fa-5896-8787-9cf9edf87328","html":"<h1 id=\"类型转换\"><a href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\" aria-label=\"类型转换 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>类型转换</h1>\n<p>类型在运行时与定义时，都或多或少的有不同的类型转换。</p>\n<h2 id=\"装箱操作\"><a href=\"#%E8%A3%85%E7%AE%B1%E6%93%8D%E4%BD%9C\" aria-label=\"装箱操作 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>装箱操作</h2>\n<ul>\n<li>\n<p>在基本类型上能调用方法，是在使用“.”运算符时提供了装箱操作，给基本类型构造一个临时对象。</p>\n</li>\n<li>\n<p>每个基本类型都有对应的类对象，装箱操作时是对基本类型转换为对应的对象。</p>\n</li>\n<li>\n<p>call方法也是装箱操作的一种实践。</p>\n</li>\n<li>\n<p>typeof主要作用还是区分基本类型和对象类型。</p>\n</li>\n<li>\n<p>每个装箱对象，都有私有类型class，通过Object.prototype.toString()可以检测唯一类型描述，比instanceOf更精准</p>\n<h2 id=\"拆箱转换\"><a href=\"#%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2\" aria-label=\"拆箱转换 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>拆箱转换</h2>\n</li>\n<li>\n<p>拆箱操作指的是将对象类型转换为基本类型。</p>\n</li>\n<li>\n<p>拆箱操作主要规格为ecma 中的 ToPrimitive(input[,preferredType]),如果有传入类型或者规则，则优先进行转换为数字或者字符串</p>\n</li>\n<li>\n<p>es6之后可以修改默认toPrimitive函数o[symbol.toPrimitive],可以修该默认的拆箱操作\n例子：对对象原型链上的valueOf()、toString()进行改造，当进行拆箱操作的时候加法规则使得先调用valueOf规则。\n<code class=\"language-text\">var o ={\n    valueOf : () =&gt;{return &quot;world!&quot;},\n    toString : () =&gt; {return &quot;xueLing!&quot;}\n};\nconsole.log(&quot;hello &quot; + o);\n//hello world!</code></p>\n<h1 id=\"javascript对象\"><a href=\"#javascript%E5%AF%B9%E8%B1%A1\" aria-label=\"javascript对象 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>javaScript对象</h1>\n<h2 id=\"对象的特点\"><a href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9\" aria-label=\"对象的特点 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对象的特点</h2>\n</li>\n<li>\n<p>有唯一标识</p>\n</li>\n<li>\n<p>有状态</p>\n</li>\n<li>\n<p>有行为\njavascript中有唯一的标识，但是状态和行为统一定义为了属性。</p>\n<h2 id=\"属性\"><a href=\"#%E5%B1%9E%E6%80%A7\" aria-label=\"属性 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>属性</h2>\n</li>\n<li>\n<p>属性类型</p>\n<ul>\n<li>\n<p>普通属性</p>\n<ul>\n<li>描述属性 writable、value、enumerable、configurable</li>\n</ul>\n</li>\n<li>\n<p>访问器属性</p>\n<ul>\n<li>\n<p>描述属性 getter、setter、enumerable、configurable</p>\n<h2 id=\"类和原型\"><a href=\"#%E7%B1%BB%E5%92%8C%E5%8E%9F%E5%9E%8B\" aria-label=\"类和原型 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>类和原型</h2>\n<p>原型对象和类都是为了实现对象的继承实现的机制。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>原型对象主要方法</p>\n<ul>\n<li>输出原型对象的：Object.getPropertyOf()</li>\n<li>设置原型对象：Object.setPropertyOf()</li>\n<li>根据原型创造对象：Object.create()</li>\n<li>混合目标对象的属性：Object.assign()</li>\n</ul>\n</li>\n<li>\n<p>class\n`\nclass son类 extends parent{\nstatic //静态方法、属性，只能通过类进行调用\nconstructor //构造函数;内部能通过this关键字，在创建实例时实例化属性\n标识符 //在类内部顶层设置的变量，为实例中的实例化属性\n私有属性、方法 //提案用'#'关键字;或者通过在类外部声明函数,在类内部通过call方法调用。\nnew.target // new.target返回构造函数的\nsuper //调用父类的构造函数\n}\n// 私有方法实现\nclass Widget {\nfoo (baz) {\nbar.call(this, baz);\n}\n// ...\n}</p>\n<p>function bar(baz) {\nreturn this.snaf = baz;\n}\n`</p>\n<h2 id=\"对象分类\"><a href=\"#%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB\" aria-label=\"对象分类 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对象分类</h2>\n<p>javascript中分宿主对象和内置对象。</p>\n</li>\n<li>\n<p>宿主对象：浏览器中自带的对象</p>\n</li>\n<li>\n<p>内置对象：javascript语言内部自带的对象。</p>\n<h1 id=\"css规则\"><a href=\"#css%E8%A7%84%E5%88%99\" aria-label=\"css规则 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>　CSS规则</h1>\n</li>\n<li>\n<p>@规则</p>\n<ul>\n<li>@chartset</li>\n<li>@media</li>\n<li>@import</li>\n<li>@page</li>\n<li>@counter-style</li>\n<li>@key-frames</li>\n<li>@fontface</li>\n<li>@support</li>\n<li>@namespace</li>\n<li>@viewport</li>\n</ul>\n</li>\n<li>\n<p>普通规则</p>\n<ul>\n<li>选择权</li>\n<li>\n<p>声明列表</p>\n<ul>\n<li>属性</li>\n<li>\n<p>值的类型</p>\n<ul>\n<li>字段</li>\n<li>\n<p>函数</p>\n<h1 id=\"浏览器如何工作的\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\" aria-label=\"浏览器如何工作的 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器如何工作的</h1>\n<p>浏览器通过url调用网络请求线程>解析报文>生成DOM树>解析css生成css规则树>合并DOM树和CSS规则树生成rander树>布局rander（layout/reflow）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","excerpt":"类型转换类型在运行时与定义时，都或多或少的有不同的类型转换。装箱操作在基本类型上能调用方法，是在使用“.”运算符时提供了装箱操作，给基本类型构造一个临时对象。每个基本类型都有对应的类对象，装箱操作时是对基本类型转换为对应的对象。call方法也是装箱操作的一种实践。typeof…","fields":{"slug":"/blog/geekbang/重学前端/javascript-运行时"},"frontmatter":{"id":"https://MuRongJs.github.io/blog/geekbang/重学前端/javascript-运行时","title":"geekbang--javascript运行时","slug":"/blog/geekbang/重学前端/javascript-运行时","date":"2019/4/22 9:22:26","headerImage":""}},"previous":null,"next":null}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"51ce5e2b-74fa-5896-8787-9cf9edf87328","index":0}}